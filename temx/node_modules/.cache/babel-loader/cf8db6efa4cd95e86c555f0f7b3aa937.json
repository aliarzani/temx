{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _inputCore = require('input-core');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar KEYBOARD = {\n  BACKSPACE: 8,\n  DELETE: 46\n};\n/**\n * React-MaskInput component\n * Params:\n * `mask`: String. Format:\n *   0 — any number 0-9\n *   * — any symbol\n *   a — A-Z, a-z\n *   q — \"q\" letter, 2 — \"2\" letter etc.\n *   \\a — \"a\" letter\n * default is undefined\n *\n * [function] `reformat`: user function, if you want use custom reformat logic. It's userfull for numeric inputs.\n * If reformat defined mask'll be ignored. Reformat function must receive object with several fields:\n * function reformat({data: data, selection: {start, end}, input}) {\n *     // realisation\n *\n *     return {\n *         [any] value: value that store and calling in input core funcitons (such as reformat). value may have any format,\n *         [String] visibleValue: value that displayed to user in input if showMask is false,\n *         [String] maskedValue: value that  displayed to user in input if showMask is true,\n *         [{[integer] start, [integer] end}] selection: {start, end} — new selection range\n *     }\n * }\n *\n * if `reformat` and `mask` is undefined, input allow to enter any values.\n *\n * You can define custom mask by passing `maskFormat`. This prop must be an array,\n * each object in array have several fields:\n * str: matched char for mask\n * regexp: validation rule as regexp\n * type: special\n *\n * `maskChar`: Character to cover unfilled editable parts of mask. Default value is ''.\n * `maskString`: String to cover unfilled editable parts of mask. Default is undefined. If maskString define maskChar ignored.\n *\n * showMask: show mask in input. It's possible only if mask have not cyclic. Default value = false\n * alwaysShowMask: show mask when input inactive\n *\n * Callbacks:\n *   onValueChange(event). event is:\n *     unformattedValue: unformatted value,\n *     value: visible value\n *   getReference: callback to get input ref\n * All other props'll passed to input directly\n */\n\nvar MaskInput = function (_Component) {\n  _inherits(MaskInput, _Component);\n\n  function MaskInput(props, context) {\n    _classCallCheck(this, MaskInput);\n\n    var _this = _possibleConstructorReturn(this, (MaskInput.__proto__ || Object.getPrototypeOf(MaskInput)).call(this, props, context));\n\n    _this.showValue = function () {\n      if (_this.state.showMask && (_this.canSetSelection || _this.props.alwaysShowMask)) {\n        _this.refs.input.value = _this.input.getMaskedValue();\n        return;\n      }\n\n      _this.refs.input.value = _this.input.getVisibleValue();\n    };\n\n    _this.setSelection = function () {\n      if (!_this.canSetSelection) {\n        return;\n      }\n\n      var selection = _this.input.getSelection();\n\n      _this.refs.input.setSelectionRange(selection.start, selection.end);\n\n      var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (fn) {\n        return setTimeout(fn, 0);\n      }; // For android\n\n\n      raf(function () {\n        return _this.refs.input.setSelectionRange(selection.start, selection.end);\n      });\n    };\n\n    _this.onPaste = function (e) {\n      e.preventDefault();\n\n      _this.getSelection(); // getData value needed for IE also works in FF & Chrome\n\n\n      _this.input.paste(e.clipboardData.getData('Text'));\n\n      _this.showValue(); // Timeout needed for IE\n\n\n      setTimeout(_this.setSelection, 0);\n      _this.props.onChange && _this.props.onChange(e);\n    };\n\n    _this.onChange = function (e) {\n      var currentValue = void 0;\n\n      if (_this.state.showMask && (_this.canSetSelection || _this.props.alwaysShowMask)) {\n        currentValue = _this.input.getMaskedValue();\n      } else {\n        currentValue = _this.input.getVisibleValue();\n      } // fix conflict by update value in mask model\n\n\n      if (e.target.value !== currentValue) {\n        _this.getSelection();\n\n        _this.input.setValue(e.target.value);\n\n        _this.showValue();\n\n        setTimeout(_this.setSelection, 0);\n      }\n\n      _this.props.onChange && _this.props.onChange(e);\n    };\n\n    _this.onKeyPress = function (e) {\n      if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') {\n        return;\n      }\n\n      e.preventDefault();\n\n      _this.getSelection();\n\n      _this.input.input(e.key || e.data || String.fromCharCode(e.which));\n\n      _this.showValue();\n\n      _this.setSelection();\n\n      _this.props.onChange && _this.props.onChange(e);\n    };\n\n    _this.onKeyDown = function (e) {\n      if (e.which === KEYBOARD.BACKSPACE) {\n        e.preventDefault();\n\n        _this.getSelection();\n\n        _this.input.removePreviosOrSelected();\n\n        _this.showValue();\n\n        _this.setSelection();\n\n        _this.props.onChange && _this.props.onChange(e);\n      }\n\n      if (e.which === KEYBOARD.DELETE) {\n        e.preventDefault();\n\n        _this.getSelection();\n\n        _this.input.removeNextOrSelected();\n\n        _this.showValue();\n\n        _this.setSelection();\n\n        _this.props.onChange && _this.props.onChange(e);\n      }\n    };\n\n    _this.onFocus = function (e) {\n      _this.canSetSelection = true;\n      _this.props.onFocus && _this.props.onFocus(e);\n    };\n\n    _this.onBlur = function (e) {\n      _this.canSetSelection = false;\n      _this.props.onBlur && _this.props.onBlur(e);\n    };\n\n    _this.input = (0, _inputCore.createInput)({\n      value: props.value || props.defaultValue || '',\n      reformat: props.reformat,\n      maskString: props.maskString,\n      maskChar: props.maskChar || _inputCore.defaults.maskChar,\n      mask: props.mask || _inputCore.defaults.mask,\n      maskFormat: props.maskFormat || _inputCore.defaults.maskFormat\n    });\n    _this.state = {\n      showMask: props.alwaysShowMask || props.showMask\n    };\n\n    _this.applyValue = function (value) {\n      _this.input.setValue(value);\n\n      if (_this.state.showMask && (_this.canSetSelection || _this.props.alwaysShowMask)) {\n        _this.refs.input.value = _this.input.getMaskedValue();\n        return;\n      }\n\n      _this.refs.input.value = _this.input.getVisibleValue();\n    };\n\n    return _this;\n  }\n\n  _createClass(MaskInput, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var updated = false;\n\n      if (this.props.alwaysShowMask !== nextProps.alwaysShowMask || this.props.showMask !== nextProps.showMask) {\n        this.setState({\n          showMask: nextProps.alwaysShowMask || nextProps.showMask\n        });\n      }\n\n      if (nextProps.reformat !== this.props.reformat) {\n        this.input.setReformat(nextProps.reformat);\n        updated = true;\n      }\n\n      if (nextProps.maskFormat && nextProps.maskFormat !== this.props.maskFormat) {\n        this.input.setMaskFormat(nextProps.maskFormat);\n        updated = true;\n      }\n\n      if (nextProps.mask !== this.props.mask) {\n        this.input.setMask(nextProps.mask);\n        updated = true;\n      }\n\n      if (nextProps.maskString !== this.props.maskString) {\n        this.input.setMaskString(nextProps.maskString);\n      }\n\n      if (nextProps.maskChar !== this.props.maskChar) {\n        this.input.setMaskChar(nextProps.maskChar);\n        updated = true;\n      }\n\n      if (nextProps.value !== this.props.value) {\n        this.input.setValue(nextProps.value);\n        updated = true;\n      }\n\n      if (updated) {\n        if (this.canSetSelection && nextProps.showMask || nextProps.alwaysShowMask) {\n          this.refs.input.value = this.input.getMaskedValue();\n        } else {\n          this.refs.input.value = this.input.getVisibleValue();\n        }\n\n        this.setSelection();\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.showValue();\n      this.props.getReference && this.props.getReference(this.refs.input);\n    }\n  }, {\n    key: 'getSelection',\n    value: function getSelection() {\n      this.input.setSelection({\n        start: this.refs.input.selectionStart,\n        end: this.refs.input.selectionEnd\n      });\n    }\n  }, {\n    key: 'keyPressPropName',\n    value: function keyPressPropName() {\n      if (typeof navigator !== 'undefined' && navigator.userAgent.match(/Android/i)) {\n        return 'onBeforeInput';\n      }\n\n      return 'onKeyPress';\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          onChange = _props.onChange,\n          onValueChange = _props.onValueChange,\n          mask = _props.mask,\n          direction = _props.direction,\n          getReference = _props.getReference,\n          showMask = _props.showMask,\n          maskChar = _props.maskChar,\n          alwaysShowMask = _props.alwaysShowMask,\n          customMaskFormat = _props.customMaskFormat,\n          maskString = _props.maskString,\n          reformat = _props.reformat,\n          value = _props.value,\n          defaultValue = _props.defaultValue,\n          inputProps = _objectWithoutProperties(_props, ['onChange', 'onValueChange', 'mask', 'direction', 'getReference', 'showMask', 'maskChar', 'alwaysShowMask', 'customMaskFormat', 'maskString', 'reformat', 'value', 'defaultValue']);\n\n      var keyPressEvent = _defineProperty({}, this.keyPressPropName(), this.onKeyPress);\n\n      return _react2.default.createElement('input', _extends({}, inputProps, {\n        onChange: this.onChange,\n        onKeyDown: this.onKeyDown,\n        onPaste: this.onPaste,\n        onFocus: this.onFocus,\n        onBlur: this.onBlur\n      }, keyPressEvent, {\n        ref: 'input'\n      }));\n    }\n  }]);\n\n  return MaskInput;\n}(_react.Component);\n\nexports.default = MaskInput;","map":null,"metadata":{},"sourceType":"script"}